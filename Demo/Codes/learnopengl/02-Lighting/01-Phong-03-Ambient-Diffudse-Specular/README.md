# README

## 1. 关于 *glm* 的矩阵乘法

+ **只是列优先存储而已，具体的计算和我们定义的一致**



### 1.1 矩阵 * 向量

```c++
// 列优先存储
// 对应到我们实际的矩阵应该是 a[0][0] = a[0][1] = 0
// 存储的矩阵应该是 a[0][0] = a[1][0] = 0
glm::mat4 aa(
    1, 0, 0, 0,
    1, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
);
glm::vec4 bb(1, 2, 3, 4);
glm::vec4 cc;

// 右乘就对应着实际上的右乘 M[4*4] * V[4*1]
cc = aa * bb; // 3 0 0 0
for (int i = 0; i < 4; ++i) {
    std::cout << cc[i] << std::endl;
}

// 左乘就对应着实际上的左乘 V[1*4] * M[4*4]
cc = bb * aa; // 1 1 0 0 
for (int i = 0; i < 4; ++i) {
    std::cout << cc[i] << std::endl;
}
```



### 1.1 矩阵 * 矩阵

```c++
/*
 * 1, 1, 0, 0,        1, 0, 0, 0,
 * 0, 0, 0, 0,        1, 0, 0, 0,
 * 0, 0, 0, 0,   =>   0, 0, 0, 0,
 * 0, 0, 0, 0,        0, 0, 0, 0,
 */
glm::mat4 aa(
    1, 1, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
);

/*
 * 1, 0, 0, 0,        1, 1, 0, 0,
 * 1, 0, 0, 0,        0, 0, 0, 0,
 * 0, 0, 0, 0,   =>   0, 0, 0, 0,
 * 0, 0, 0, 0,        0, 0, 0, 0,
 */
glm::mat4 bb(
    1, 0, 0, 0,
    1, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
);
glm::mat4 cc;

/*
 * 1, 1, 0, 0,        1, 1, 0, 0,
 * 1, 1, 0, 0,        1, 1, 0, 0,
 * 0, 0, 0, 0,   =>   0, 0, 0, 0,
 * 0, 0, 0, 0,        0, 0, 0, 0,
 */
cc = aa * bb;
for (int i = 0; i < 4; ++i) {
    for (int j = 0; j < 4; ++j) {
        std::cout << cc[i][j] << std::endl;
    }
}


/*
 * 2, 0, 0, 0,        2, 0, 0, 0,
 * 0, 0, 0, 0,        0, 0, 0, 0,
 * 0, 0, 0, 0,   =>   0, 0, 0, 0,
 * 0, 0, 0, 0,        0, 0, 0, 0,
 */
cc = bb * aa;
for (int i = 0; i < 4; ++i) {
    for (int j = 0; j < 4; ++j) {
        std::cout << cc[i][j] << std::endl;
    }
}
```

